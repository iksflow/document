# 역사
<br></br>

## 학습목표
* 현대 운영체제로 발전하게된 역사배경을 설명할 수 있다.
<br></br>

## 1. 운영체제가 없던 시절 (1940년대)
<br></br>
아주 옛날 초창기의 컴퓨터에는 OS가 없었다.  
프로그래머는 프로그램의 소스코드를 천공카드에 작성했으며, 컴파일러를 탑재, 라이브러리 링크, 메모리 로드 등의 작업들을 직접 처리해야했다.  
코드를 실행하는것 외에도 컴퓨터를 구동하기 위해 할일이 매우 많았던것이다.  
그래서 이런 부수적인 업무를 담당하는 오퍼레이터(Operator)라는 별도의 직군이 존재했다.  
<br></br>

## 2. 일괄처리 시스템(Batch processing system)
<br></br>
일련의 작업들을 오퍼레이터가 수작업으로 처리하는 상황은 굉장히 불편했다.  
그래서 당시 사람들은 오퍼레이터의 업무를 대신 수행하는 프로그램을 만들자는 생각에 도달했고 이것이 일괄처리 시스템이 탄생하게된 배경이 되었다.  
그렇게 메모리에 상주하면서 오퍼레이터의 컴파일러 탑재, 라이브러리 링크, 메모리 로드 등의 업무를 일괄적으로 처리하는 프로그램을 만들게 된다.  
이렇게 탄생한 프로그램이 최초의 OS였으며 Resident monitor라고 불렸다.  
<br></br>

## 3. 다중프로그래밍 시스템(Multiprogramming system)
<br></br>
다중프로그래밍 시스템이 생기기 전의 OS는 메모리의 프로세스 중 1개만을 실행할 수 있었다.  
실행중인 프로세스가 작업이 끝나면 다음 프로세스를 처리하는 방식이었다.  
당시 CPU는 굉장히 비싼 자원이었는데, CPU의 처리속도는 I/O에 비해 굉장히 빠른것이 문제가 되었다.  
그 이유는 프로그램을 처리하는 과정에서 CPU가 I/O의 작업이 완료되기를 기다리는 동안, CPU를 활용하지 못하고 놀리는 상황(Idle)이 자주 발생했기 때문이다.  
그래서 사람들은 프로세스를 처리하는 과정에서 I/O를 만나게 되면, CPU는 다음 프로세스로 이동해 처리할 수 있도록 하는 방안을 고안했다.
바로 다중프로그래밍 시스템이다.  
다중프로그래밍의 탄생은 또 다른 문제거리들을 해결해야만 했다.  
그것들은 바로 기존의 단일 프로그래밍 시스템에서는 신경쓰지 않아도 됐을 CPU 스케쥴링, 메모리관리, 보호등이다.
<br></br>

## 4. 시공유(시분할) 시스템(Time-sharing system)
<br></br>

다중프로그래밍 시스템의 시대가 되면서 컴퓨터는 동시에 더 많은 일들을 할 수 있게 되었다.  
아직도 컴퓨터는 굉장히 비싼 자원이었기 때문에 여러 사람이 컴퓨터를 같이 사용해야 하는 상황이었다.  
하지만 다중 프로그래밍으로는 해결하지 못하는 부분이 있었는데, 사용자에게 균일하게 CPU를 분배할 수 없다는점이었다.  
다중 프로그래밍은  I/O 작업을 만나야만 다음 프로세스로 이동한다.
그런데 만약 프로세스가 계산이 오래걸리거나, 무한루프에 빠지게 되면 프로세스가 순환하지 않는 상황이 발생하게 된다.  
그러면 한명의 유저가 CPU를 차지하는 동안 다른 유저들은 처리중인 프로세스가 완료될 때 까지 대기할 수 밖에 없는 상황이 되어버렸다.  
이 문제를 해결하기 위해 시분할 시스템이 등장하게 되었다.  
CPU는 일정한 시간마다 프로세스를 순환하면서 골고루 작업을 처리했다.  
CPU는 속도가 굉장히 빠르므로 사용자들에게 동시에 여러 유저의 프로세스를 처리하는듯한 느낌을 줄 수 있었다.
오늘날 대부분의 시스템은 시분할 시스템으로 되어있다.

<br></br>


## Reference
* 양희재 교수님의 운영체제 강의  
https://www.youtube.com/watch?v=mcS4n34wBcY&list=PLK4xviZcdB9ieuusJ5j1UYZMFTuAgZCq8&index=1