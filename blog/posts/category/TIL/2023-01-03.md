# 오늘 한 것
* "좋은 코드 나쁜 코드" 2장 읽기.
* Nest.js 프로젝트 세팅.

***
좋은 코드 나쁜 코드의 2장에서는 추상화 계층에 대해 설명한다.  
추상화를 했을 경우 얻게 되는 가독성, 모듈화, 재사용성 등의 이점을 예제 코드와 함께 소개한다.  
비대한 클래스를 재사용성과 테스트 용이성을 향상시킨 버전으로 리팩토링하는 예시가 있다.  
"역할"의 판단 기준, "private", "public" 같은 접근제한자를 사용해 공개 범위를 설정하는 기준, 인터페이스를 활용해 언제든 교체가능하도록 만드는 방법, 코드의 추상화 수준 등을 예제 코드를 리팩토링하는 과정에서 잘 설명해줘서 이해하기 쉬웠다.  
코드를 추상화하고 모듈화할 때 어느 정도까지 작게 만들어야 하는지 궁금한 적이 많았는데 결론은 "그때 그때 다르다"라고 얘기하는 것 같다.  
결국 프로덕트의 도메인이나 방향성에 따라 추상화 수준이 달라질 수 있으므로 명확하게 공식화하는것이 불가능하다.  
추상화하지 않아서 코드 계층이 너무 두꺼우면 의미를 파악하기 어렵고 재사용이 힘들다.  
또한 코드 계층을 너무 세분화하거나 분할을 위한 분할로 코드 계층을 필요 이상으로 얇고 복잡하게 만들어서도 안된다.  
경험이 많은 개발자도 어려운 영역이기 때문에 올바른 추상화 계층을 만들기 까지 여러번 설계를 반복하며 완성해나간다.  

</br> 

***
</br>  

Nest.js 로 백엔드 개발을 해보려고 프로젝트를 세팅했다.  
진행에 참고한 문서는 공식 문서와 NestJS로 배우는 백엔드 프로그래밍.  
* [Nest공식 문서](https://docs.nestjs.com/)
* [NestJS로 배우는 백엔드 프로그래밍](https://wikidocs.net/book/7059)

</br> 

***
</br>  

# 오늘 배운 것

## 1. 좋은 코드 나쁜 코드 - 2장 추상화 계층
### 요약
  * 추상화 계층을 잘 만들면 가독성, 모듈화, 재사용성, 일반화 및 테스트 용이성이 향상된다.
  * 특정 언어에 국한된 기능 뿐 아니라 함수, 클래스, 인터페이스를 사용해 코드를 추상화 계층으로 나눌 수 있다.
  * 코드를 추상화 계층으로 분류하는 기준은 해결 중인 문제에 대해 판단할 지식이 있어야한다.
  * 너무 비대한 계층 때문에 발생하는 문제는 너무 얇아서 발생하는 문제보다 더 심각하다.  불확실한 경우 남용하더라도 계층을 얇게 만드는 것이 좋은 경우가 많다.
  
### 추상화 계층을 만드는 이유
복잡한 문제를 쉽게 다룰 수 있다.  
HTTP 연결에 대한 작업을 예로 들면 대부분의 언어에서는 이미 추상화 되어있기 때문에 URL, 연결, 메시지 문자열 보내기, 연결 닫기만으로 연결을 구현할 수 있다.  
실제로는 세션, TCP 연결, 네트워크 상태 등등의 복잡한 문제에 대해서도 고려해야하지만 추상화가 잘 되어있어서 사용자는 쉽게 연결할 수 있다.  

### 추상화 계층 및 코드 품질의 핵심 요소
* 가독성
* 모듈화
* 재사용성 및 일반화성
* 테스트 용이성

### 함수로 계층을 잘 나누기 위해 지키면 좋은 것
* 단일 업무 수행
* 잘 명명된 다른 함수를 호출해서 더 복잡한 동작을 구성

### 클래스로 계층을 잘 나누기 위해 지키면 좋은 것
* 300줄을 넘지 않도록 작성
* 응집력
* 관심사의 분리

### 인터페이스 단일 구현
확장의 가능성이 없을 것 처럼 보여도 인터페이스를 만들고 해당 인터페이스를 구현하는 단일 클래스(Impl)를 설계하는 방법이 좋다.  프로그램은 어떻게 바뀔지 아무도 알 수 없기 떄문이다.
장점
* 퍼블릭 API를 명확하게 보여준다. (인터페이스에서 구현한 메서드만 공개되므로)
* 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다.
* 테스트를 쉽게할 수있다. Mock 객체 생성이 용이하다.
* 같은 클래스로 하위문제를 해결할 수 있다.

단점
* 더 많은 작업이 필요하다. 작성할 코드가 많다
* 코드가 복잡해질 수 있다.

